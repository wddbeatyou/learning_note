## 计算机相关基础知识

### 一、IP地址，子网掩码、默认网关与DNS

#### 1.1 IP地址

```
略
```

#### 1.2 子网掩码

```
略
```

#### 1.3 默认网关

```
含义：
	就是一个网络连接到另一个网络的“关口”。网关实质上是一个网络通向其它网络的IP地址。这个IP地址，是具有路由功能的IP地址，
	默认网关也是一个网关，也是具有路由功能的设备的IP地址。注意：在填写默认网关时，主机的IP地址必须和默认网关的IP地址处于同一段。
解释：
	如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，
	网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程也是如此。
	所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。
```

1.4 域名DNS

```
含义：
	DNS地址是一个域名服务器地址，它负责把用户的网站地址解析成IP地址。如果这个服务器出现问题，那么你就可能上不了网了。
解释：
	DNS 全名叫 Domain Name Server，中文俗称“域名服务器”，在说明 DNS Server 之前，可能要先说明什么叫 Domain Name(域名)。
	正如上面所讲，在网上辨别一台电脑的方法是利用 IP地址，但是 IP用数字表示，没有特殊的意义，很不好记，因此，
	我们一般会为网上的电脑取一个有某种含义又容易记忆的名字，这个名字我们就叫它“DomainName"。
```

### 二、 conda安装流程

```
wget http://repo.continuum.io/miniconda/Miniconda3-latest-Linux-aarch64.sh
sudo bash Miniconda3-latest-Linux-aarch64.sh
sudo vim ~/.bashrc
export PATH="/home/orin/anaconda/miniconda3/bin:$PATH"
source ~/.bashrc
source activate
conda deactivate
conda create -n yolo python=3.8
conda activate yolo
conda config --add envs_dirs /home/orin/anaconda/miniconda3/envs
```

### 三、什么是eMMC，SSD和HDD

```
eMMC，全称embedded MultiMediaCard，即嵌入式多媒体卡，作用类似硬盘。
eMMC：主要应用于移动设备、汽车电子、工业控制等领域。特别是在智能手机、平板电脑和其他便携式设备中，eMMC已成为主流的存储解决方案。
固态硬盘（SSD）：大小类似内存条；
机械硬盘（HDD）：体积较大的长方体的硬件。
```

### 四、docker常用命令

```
sed的用法：
	RUN sed -i 's/archive.ubuntu.com/mirrors.aliyun.com/g' /etc/apt/sources.list && apt-get update && apt-get install -y <package>
解释：
-i：
	这个选项告诉 sed 直接修改文件内容，而不是将结果输出到屏幕。这意味着 /etc/apt/sources.list 文件将被直接修改。
s/archive.ubuntu.com/mirrors.aliyun.com/g：
	这是 sed 的脚本部分，指定了要执行的编辑操作。s 代表替换（substitute）操作，/ 是分隔符，archive.ubuntu.com 是要被替换的文本，mirrors.aliyun.com 是替换后的文本，g 表示全局替换（即替换行中所有匹配的实例，而不仅仅是第一个）。
/etc/apt/sources.list：
	这是要编辑的文件名。

RUN apt-get update && apt-get install -y --no-install-recommends <package>
--no-install-recommends：
	选项指示 apt-get 不要安装推荐的软件包。推荐的软件包是那些被认为与指定软件包一起使用很好的软件包，但它们不是必需的。这个选项可以减小安装后的镜像大小，因为它避免了安装可能不需要的额外软件包。
```

### 五、docker镜像运行和打包全过程

```
1.配置镜像源
	sudo vim /etc/docker/daemon.json
    添加：
        {
          "registry-mirrors": ["https://docker.registry.cyou",
                                "https://docker-cf.registry.cyou",
                                "https://dockercf.jsdelivr.fyi",
                                "https://docker.jsdelivr.fyi",
                                "https://dockertest.jsdelivr.fyi",
                                "https://mirror.aliyuncs.com",
                                "https://dockerproxy.com",
                                "https://mirror.baidubce.com",
                                "https://docker.m.daocloud.io",
                                "https://docker.nju.edu.cn",
                                "https://docker.mirrors.sjtug.sjtu.edu.cn",
                                "https://docker.mirrors.ustc.edu.cn",
                                "https://mirror.iscas.ac.cn",
                                "https://docker.rainbond.cc"]
    }
    #重启docker
    sudo systemctl daemon-reload
    sudo systemctl restart docker
2.检查配置情况，拉取镜像
	docker pull mysql
3.编写Dockerfile
4.生成镜像
	docker build -t 镜像名 .
5.运行镜像和停止容器
    方式一：编写yml文件，使用docker compose方式管理
        前台运行：docker compose up
        后台运行：docker compose up -d --force-recreate
        停止容器：docker compose down

    方式二：生成容器直接运行
        前台运行：docker run -it --name=容器名 镜像名:标签 /bin/bash
        后台运行：docker run -di --name=容器名 镜像名:标签 /bin/bash
        停止容器：docker stop 容器id
6.打包镜像
	docker save -o xxxx.tar xxx:latest
7.加载镜像
	docker load -i xxx.tar
8.查看日志
	docker logs 容器id
9.进入容器内部
	docker exec -it 容器id /bin/bash
10.删除镜像
	docker rmi 镜像ID
	docker rmi 镜像ID --force
11.拉取镜像
	docker pull 镜像名称
12.推送镜像
	本地推送：
		docker push [镜像名]:[标签]
	远程推送：
        docker login --username=wdd930817 registry.cn-hangzhou.aliyuncs.com
        docker tag 镜像ID registry.cn-hangzhou.aliyuncs.com/wdd_project/wdd_docker:版本号
        docker push registry.cn-hangzhou.aliyuncs.com/wdd_project/wdd_docker:[镜像版本号]
13.查看镜像
	docker images
14.查看容器
    查看运行容器：	
        docker ps
    查看所有容器：	
        docker ps -a
15.容器生成镜像
	docker run --name 容器名 镜像名 /bin/bash
	docker commit 容器名 镜像名
16.镜像生成容器
	docker run -it --name=容器名 镜像名:标签 /bin/bash
17.启动容器
	docker start 容器名称（或者容器ID）
18.将容器内的文件复制到本机上
	docker cp <container_id>:<container_path> <host_path>
19.清理掉所有未被使用的数据，包括未被打标签的镜像、停止的容器、未使用的网络和悬挂的卷。通常是释放Docker占用空间的最有效方法。
	docker system prune -a
20.设置开机自启
    第一步：先启动容器：
        docker run -d --name mediamtx -e MTX_RTSPTRANSPORTS=tcp -p 8554:8554 bluenviron/mediamtx
        docker run -d --name mediamtx \
          -e MTX_RTSPTRANSPORTS=tcp \
          -e MTX_WEBRTCADDITIONALHOSTS=172.20.31.102 \
          -p 8554:8554 \
          -p 1935:1935 \
          -p 8888:8888 \
          -p 8889:8889 \
          -p 8890:8890/udp \
          -p 8189:8189/udp \
          bluenviron/mediamtx
    第二步：设置开机自启：
    	docker update --restart=always mediamtx
21.取消开机自启
	docker update --restart=no mediamtx
22. 彻底禁用 Docker 服务自启（谨慎操作）
    sudo systemctl disable docker
23.恢复 Docker 服务自启
	sudo systemctl enable docker
```

### 六、Jetson Orin Nano的torch安装

```
第一步：进入官网：https://forums.developer.nvidia.com/t/pytorch-for-jetson/72048
第二步：查看jetpack版本：sudo apt-cache show nvidia-jetpack，如：Version: 5.1.2-b104
第三步：下载jetpack版本对应的torch版本： torch-2.1.0a0+41361538.nv23.06-cp38-cp38-linux_aarch64.whl
第四步：安装torch：pip install torch-2.1.0a0+41361538.nv23.06-cp38-cp38-linux_aarch64.whl
第五步：安装相关依赖：
    sudo apt --fix-broken install
    sudo apt update
    sudo apt install libopenblas-dev
第六步：查看结果：
    import torch
    print(torch.__version__)
    print(torch.cuda.is_available())
```

### 七、FFmpeg，Mediamtx与VLC 

#### 7.1 FFmpeg

```
定义：FFmpeg是一款强大的多媒体处理工具，它负责将视频文件进行编码并推送到流媒体服务器上。
FFmpeg主要执行以下任务：
	读取视频文件：FFmpeg可以从本地文件系统或网络位置读取视频文件。
	编码转换：根据需要将视频文件转换为流媒体服务器可以接受的格式和编码。
	推流：将编码后的视频流推送到指定的流媒体服务器地址和端口。
```

#### 7.2 Mediamtx

```
定义：Mediamtx在这里作为流媒体服务器，它负责接收FFmpeg推送的视频流，并将其提供给VLC或其他客户端进行拉流播放。
流媒体服务器的主要功能包括：
	接收推流：从FFmpeg等推流工具接收视频流。
	流媒体处理：对流媒体数据进行处理，如转发、录制、广播等。
	提供拉流服务：将处理后的视频流提供给VLC或其他支持RTSP、RTMP等协议的客户端进行播放。
```

#### 7.3 VLC

```
定义：VLC（VideoLAN Client）是一款开源的多媒体播放器，它支持多种音频和视频格式以及流媒体协议。在这里，VLC作为拉流工具，负责从流媒体服务器接收视频流并在本地进行播放。
VLC的主要功能包括：
	拉流：从流媒体服务器接收RTSP、RTMP等协议的视频流。
	播放：在本地播放接收到的视频流。
	调整播放设置：如调整音量、亮度、对比度等播放参数。
```

#### 7.4 案例

```
命令：ffmpeg -re -i E:\vlc\test.mp4 -c copy -rtsp_transport tcp -f rtsp rtsp://172.20.31.57:8554/stream1
解释：
	ffmpeg: 调用ffmpeg程序。
	-re: 以本地帧率读取输入文件。这对于模拟实时流媒体传输非常有用，确保发送的数据流的速度与原始视频的速度相匹配。
	-i C:\Users\suolide-zjq\Desktop\mp4\1.mp4: 指定输入文件，这里是位于C:\Users\suolide-zjq\Desktop\mp4\目录下的1.mp4文件。
	-c copy: 表示在编码过程中不对视频和音频流进行重新编码，直接复制。这可以大大节省处理时间和保持原始质量，但前提是原始编码格式与目标流媒体服务器或客户端兼容。
	-rtsp_transport tcp: 指定RTSP传输层使用TCP协议。RTSP（Real Time Streaming Protocol）是一种网络控制协议，用于控制流媒体数据的传输。TCP（Transmission Control Protocol）是一种可靠的、面向连接的协议，尽管可能引入一些延迟，但能够确保数据的完整性和顺序。
	-f rtsp: 指定输出文件的格式是RTSP。这告诉ffmpeg输出应该被格式化为RTSP流，以便可以通过网络进行流媒体传输。
	rtsp://192.168.2.23:8554/stream: 指定RTSP流的URL。这里，rtsp://是协议部分，192.168.2.23是RTSP服务器的IP地址，8554是服务器监听的端口号，/stream是流的路径或名称。这个URL是ffmpeg将视频流发送到的目的地。
```

### 八、ZLMediaKit服务

```
切换：/home/orin/ZLMediaKit/release/linux/Debug
运行：./MediaServer 
```

### 九、C++模型转换

```
命令：/usr/src/tensorrt/bin/trtexec --onnx=best.onnx --saveEngine=best.engine
```

### 十、带宽

```
定义：
	带宽（Bandwidth）是一个核心概念，用于衡量数据传输或处理的能力。具体含义取决于上下文，但核心思想是描述单位时间内可传输或处理的数据量。
	
通用定义:
    带宽表示 “数据通道的容量”，通常以 单位时间内传输的数据量 衡量，常用单位包括：
    比特率：bps（比特/秒）、Gbps（千兆比特/秒）
    字节率：MB/s（兆字节/秒）、GB/s（千兆字节/秒）
```

#### 10.1 网络带宽

```
定义：网络链路（如Wi-Fi、光纤）的最大数据传输速率。
示例：
    千兆以太网的带宽是 1 Gbps（每秒传输10亿比特）。
    下载文件时，实际速度受带宽限制（如100 Mbps带宽下载速度约12.5 MB/s）。
```

#### 10.2  内存带宽--RAM/显存

```
定义：内存或显存与处理器（CPU/GPU）之间数据传输的速率。
计算公式：
	带宽 = 位宽 × 频率 × 通道数
示例：
    DDR4内存（64位宽、3200 MHz、双通道）的带宽：
    	64-bit × 3200 MHz × 2 ≈ 51.2 GB/s
    NVIDIA RTX 4090显存（GDDR6X，384位宽，21 Gbps）：
    	384-bit × 21 Gbps / 8 ≈ 1 TB/s
```

#### 10.3 存储带宽--硬盘/SSD

```
定义：存储设备（如SSD）读写数据的最大速率。
示例：
    PCIe 4.0 NVMe SSD的读取带宽可达 7 GB/s。
    HDD的带宽通常只有 100-200 MB/s。
```

#### 10.4 计算带宽--CPU/GPU

```
定义：处理器从内存中获取数据并计算的能力。
关键问题：
    “内存墙”：计算单元的速度常远超内存带宽，导致等待数据（瓶颈）。
    优化目标：通过缓存、数据预取等技术提高有效带宽利用率。
```

#### 10.5 并行编程中的带宽--CUDA

```
显存带宽：GPU显存与计算核心间的数据传输速率（如NVIDIA H100的显存带宽约3 TB/s）。
共享内存带宽：GPU片上内存的带宽极高（约10 TB/s），用于减少显存访问延迟。
```

#### 10.6 带宽 vs 延迟

| **特性**     | **带宽（Bandwidth）**          | **延迟（Latency）**      |
| :----------- | :----------------------------- | :----------------------- |
| **定义**     | 单位时间的数据量               | 数据从起点到终点的时间   |
| **关注点**   | “能跑多快”                     | “需要等多久”             |
| **示例**     | 水管每秒流过多少升水（吞吐量） | 水从开水龙头到出水的时间 |
| **优化方法** | 增加通道数、提高频率           | 减少传输距离、使用缓存   |

### 十一、SM

```
基本定义：
	全称：Streaming Multiprocessor；
SM是GPU的核心计算单元：
    每个SM包含多个CUDA核心（如NVIDIA Ampere架构的SM有128个INT32核心）、共享内存（Shared Memory）、寄存器文件（Register File）等资源。
并行执行单位：
    一个GPU由多个SM组成（例如RTX 3090有82个SM），每个SM可同时管理多个线程块（Blocks）和线程（Threads）。
```

#### 11.1 SM的关键资源

| 资源           | 作用                                                      |
| :------------- | :-------------------------------------------------------- |
| **CUDA核心**   | 执行算术和逻辑运算（如FP32/INT32计算）。                  |
| **共享内存**   | 线程块内共享的低延迟存储（通常64KB/SM，可配置为L1缓存）。 |
| **寄存器**     | 每个线程私有，存储局部变量（数量有限，影响线程数量）。    |
| **线程调度器** | 管理线程束（Warps，32线程为一组）的调度。                 |

#### 11.2 影响占有率的因素

1. **每个线程块的线程数（Block Size）**：
   - 块太小 → SM中可驻留的块多，但可能资源未充分利用。
   - 块太大 → SM中驻留的块少，可能导致占有率下降。
   - **经验值**：通常选择128~256线程/块。
2. **寄存器使用量**：
   - 每个线程使用的寄存器越多，SM中能并行的线程越少（寄存器总量固定）。
   - 可通过编译选项 `-maxrregcount=N` 限制寄存器使用。
3. **共享内存使用量**：
   - 共享内存是SM的稀缺资源，占用过多会减少活跃线程块数量。

#### 11.3 如何优化占有率

(1) 选择合适的Block Size

- 使用CUDA工具包中的 **Occupancy Calculator**（占用率计算器）或 `cudaOccupancyMaxPotentialBlockSize` API动态选择最优块大小。

  ```
  int blockSize;      // 最佳线程块大小
  int minGridSize;    // 最小网格大小
  cudaOccupancyMaxPotentialBlockSize(&minGridSize, &blockSize, myKernel, 0, 0);
  ```

**(2) 减少寄存器使用**

- 通过 `__launch_bounds__` 或编译选项限制寄存器数量：

  ```
  __global__ __launch_bounds__(256, 4) void myKernel() { ... }
  // 最大256线程/块，每个线程最多使用4个寄存器
  ```

**(3) 平衡共享内存**

- 调整共享内存分配（如将部分数据移至寄存器）：

  ```
  __shared__ float tile[32][32]; // 静态共享内存
  extern __shared__ float dynamic_shared[]; // 动态共享内存
  ```

**(4) 监控实际占有率**

- 使用 **Nsight Compute** 或 `nvprof` 工具分析核函数的实际占有率：

  ```
  nvprof --metrics achieved_occupancy ./my_program
  ```

### 十二、寄存器（Registers）

```
“64K寄存器”的含义：
    数量：指SM（Streaming Multiprocessor）中可用的32位寄存器的总数是65,536个（即64 × 1024个）。
    每个寄存器的大小：1个寄存器 = 32位（4字节）。
    总容量：64K × 4字节 = 256 KB（但通常以寄存器数量描述资源限制，而非总字节数）。

关键点：
    寄存器是线程私有的，每个线程分配的寄存器数量影响SM中可并行的线程总数。
    例如：若每个线程使用64个寄存器，则SM最多支持的线程数为：
    	64K寄存器 / 64寄存器每线程 = 1024线程
```

```
注意：
	寄存器溢出（Register Spilling）：若线程使用的寄存器超过硬件限制，编译器会将部分变量溢出到显存（大幅降低性能）。
	可通过编译选项限制寄存器使用：
		nvcc -Xptxas -maxrregcount=32 my_kernel.cu  # 限制每个线程最多32个寄存器
```

### 十三、共享内存（Shared Memory）

```
“64KB共享内存”的含义：
    容量：指SM中共享内存的总大小为64千字节（64 × 1024字节）。
    按字节分配：共享内存的分配以字节为单位（如 __shared__ float arr[1024] 占用1024 × 4 = 4096字节）。
关键点：
    共享内存是线程块内共享的，每个线程块请求的共享内存量影响SM中可驻留的线程块数。
    例如：若每个线程块请求48KB共享内存，则SM最多支持的线程块数为：
注意：
	共享内存竞争：若线程块请求的共享内存超过SM容量，会导致实际驻留块数减少（降低占有率）。
```

### 十四、operator()

```
operator() 属于 C++ 中的运算符重载。在 C++ 里，() 是函数调用运算符。当你在一个类或者结构体中重载 operator() 时，这个类或者结构体的对象就能够像函数一样被调用，这样的对象也被叫做 “函数对象” 或者 “仿函数”。
```





















